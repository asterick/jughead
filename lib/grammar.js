// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }

const lexer = require("./lexer.js");
var grammar = {
    Lexer: lexer,
    ParserRules: [
    {"name": "main$ebnf$1", "symbols": []},
    {"name": "main$ebnf$1", "symbols": ["main$ebnf$1", "statement"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "main", "symbols": ["main$ebnf$1"], "postprocess": id},
    {"name": "statement", "symbols": [{"literal":"require"}, (lexer.has("string") ? {type: "string"} : string)]},
    {"name": "statement$ebnf$1$subexpression$1", "symbols": [{"literal":"public"}]},
    {"name": "statement$ebnf$1$subexpression$1", "symbols": [{"literal":"private"}]},
    {"name": "statement$ebnf$1", "symbols": ["statement$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "statement$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "statement$ebnf$2", "symbols": []},
    {"name": "statement$ebnf$2", "symbols": ["statement$ebnf$2", "type"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "statement", "symbols": ["statement$ebnf$1", {"literal":"define"}, (lexer.has("identifier") ? {type: "identifier"} : identifier), {"literal":":"}, "statement$ebnf$2"]},
    {"name": "statement", "symbols": ["const"]},
    {"name": "access", "symbols": [{"literal":"public"}]},
    {"name": "access", "symbols": [{"literal":"private"}]},
    {"name": "type$ebnf$1$subexpression$1", "symbols": [{"literal":"("}, "parameter_list", {"literal":")"}]},
    {"name": "type$ebnf$1", "symbols": ["type$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "type$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "type", "symbols": [(lexer.has("identifier") ? {type: "identifier"} : identifier), "type$ebnf$1"]},
    {"name": "type", "symbols": [{"literal":"["}, "size", {"literal":"]"}]},
    {"name": "type$ebnf$2", "symbols": [{"literal":"struct"}], "postprocess": id},
    {"name": "type$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "type$ebnf$3", "symbols": []},
    {"name": "type$ebnf$3", "symbols": ["type$ebnf$3", "field"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "type", "symbols": ["type$ebnf$2", {"literal":"{"}, "type$ebnf$3", {"literal":"}"}]},
    {"name": "field$ebnf$1", "symbols": []},
    {"name": "field$ebnf$1", "symbols": ["field$ebnf$1", "type"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "field", "symbols": [(lexer.has("identifier") ? {type: "identifier"} : identifier), {"literal":":"}, "field$ebnf$1"]},
    {"name": "field$ebnf$2", "symbols": []},
    {"name": "field$ebnf$2", "symbols": ["field$ebnf$2", "field"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "field", "symbols": [{"literal":"section"}, {"literal":"["}, "expression", {"literal":"]"}, {"literal":"{"}, "field$ebnf$2", {"literal":"}"}]},
    {"name": "field", "symbols": [{"literal":"parameter"}, (lexer.has("identifier") ? {type: "identifier"} : identifier), {"literal":"="}, "expression"]},
    {"name": "field", "symbols": ["const"]},
    {"name": "const$ebnf$1", "symbols": ["access"], "postprocess": id},
    {"name": "const$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "const", "symbols": ["const$ebnf$1", {"literal":"const"}, (lexer.has("identifier") ? {type: "identifier"} : identifier), {"literal":"="}, "expression"]},
    {"name": "size", "symbols": [{"literal":"*"}]},
    {"name": "size", "symbols": [{"literal":"until"}, "expression"]},
    {"name": "size", "symbols": [{"literal":"while"}, "expression"]},
    {"name": "size", "symbols": ["expression_list"]},
    {"name": "parameter_list$ebnf$1", "symbols": []},
    {"name": "parameter_list$ebnf$1$subexpression$1", "symbols": [{"literal":","}, "parameter"]},
    {"name": "parameter_list$ebnf$1", "symbols": ["parameter_list$ebnf$1", "parameter_list$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "parameter_list", "symbols": ["parameter", "parameter_list$ebnf$1"]},
    {"name": "parameter$ebnf$1$subexpression$1", "symbols": [{"literal":"="}, "expression"]},
    {"name": "parameter$ebnf$1", "symbols": ["parameter$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "parameter$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "parameter", "symbols": [(lexer.has("identifier") ? {type: "identifier"} : identifier), "parameter$ebnf$1"]},
    {"name": "expression_list$ebnf$1", "symbols": []},
    {"name": "expression_list$ebnf$1$subexpression$1", "symbols": [{"literal":","}, "expression"]},
    {"name": "expression_list$ebnf$1", "symbols": ["expression_list$ebnf$1", "expression_list$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "expression_list", "symbols": ["expression", "expression_list$ebnf$1"]},
    {"name": "expression", "symbols": ["or_expression"]},
    {"name": "or_expression", "symbols": ["or_expression", {"literal":"or"}, "and_expression"]},
    {"name": "or_expression", "symbols": ["and_expression"]},
    {"name": "and_expression", "symbols": ["and_expression", {"literal":"and"}, "bit_expression"]},
    {"name": "and_expression", "symbols": ["bit_expression"]},
    {"name": "bit_expression", "symbols": ["bit_expression", {"literal":"|"}, "eq_expression"]},
    {"name": "bit_expression", "symbols": ["bit_expression", {"literal":"&"}, "eq_expression"]},
    {"name": "bit_expression", "symbols": ["bit_expression", {"literal":"^"}, "eq_expression"]},
    {"name": "bit_expression", "symbols": ["eq_expression"]},
    {"name": "eq_expression", "symbols": ["eq_expression", {"literal":"="}, "cmp_expression"]},
    {"name": "eq_expression", "symbols": ["eq_expression", {"literal":"!="}, "cmp_expression"]},
    {"name": "eq_expression", "symbols": ["cmp_expression"]},
    {"name": "cmp_expression", "symbols": ["cmp_expression", {"literal":">"}, "shift_expression"]},
    {"name": "cmp_expression", "symbols": ["cmp_expression", {"literal":">="}, "shift_expression"]},
    {"name": "cmp_expression", "symbols": ["cmp_expression", {"literal":"<"}, "shift_expression"]},
    {"name": "cmp_expression", "symbols": ["cmp_expression", {"literal":"<="}, "shift_expression"]},
    {"name": "cmp_expression", "symbols": ["shift_expression"]},
    {"name": "shift_expression", "symbols": ["shift_expression", {"literal":"<<"}, "add_expression"]},
    {"name": "shift_expression", "symbols": ["shift_expression", {"literal":">>"}, "add_expression"]},
    {"name": "shift_expression", "symbols": ["shift_expression", {"literal":">>>"}, "add_expression"]},
    {"name": "shift_expression", "symbols": ["add_expression"]},
    {"name": "add_expression", "symbols": ["add_expression", {"literal":"+"}, "mul_expression"]},
    {"name": "add_expression", "symbols": ["add_expression", {"literal":"-"}, "mul_expression"]},
    {"name": "add_expression", "symbols": ["mul_expression"]},
    {"name": "mul_expression", "symbols": ["mul_expression", {"literal":"*"}, "exp_expression"]},
    {"name": "mul_expression", "symbols": ["mul_expression", {"literal":"/"}, "exp_expression"]},
    {"name": "mul_expression", "symbols": ["exp_expression"]},
    {"name": "exp_expression", "symbols": ["top_expression", {"literal":"**"}, "exp_expression"]},
    {"name": "exp_expression", "symbols": ["top_expression"]},
    {"name": "unary_expression", "symbols": [{"literal":"~"}, "unary_expression"]},
    {"name": "unary_expression", "symbols": [{"literal":"-"}, "unary_expression"]},
    {"name": "unary_expression", "symbols": [{"literal":"not"}, "unary_expression"]},
    {"name": "unary_expression", "symbols": ["top_expression"]},
    {"name": "top_expression", "symbols": [(lexer.has("identifier") ? {type: "identifier"} : identifier)]},
    {"name": "top_expression", "symbols": [(lexer.has("number") ? {type: "number"} : number)]},
    {"name": "top_expression", "symbols": [{"literal":"nil"}]},
    {"name": "top_expression", "symbols": [{"literal":"("}, "expression", {"literal":")"}]}
]
  , ParserStart: "main"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();
